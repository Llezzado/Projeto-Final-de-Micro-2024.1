/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "stm32f1xx.h"

/*
 * macros a sererm definidas
 * */

//rcc
#define CPU_CLK_8m 	8000000
#define CPU_CLK_72m 	72000000

//timer
#define tim2_psc 72

//usart
#define BaudRate	115200

//dht11
#define DHT11_PIN 	0x200
#define DHT11_GRUPO GPIOB

//I2C1
#define OLED_ADDRESS  0x78//0x3C
#define SSD1306_I2C_ADDR         0x78
/*
 * variaveis globais
 * */

//uart
char ch = '\000';
char buffer[10];
uint8_t  buffer_index = 0;

//timer
uint8_t flag = 0;


/*
 * funções declaradas
 * */

void RCC_setup();


//usart1
void USART1_setup();
void USART1_IRQHandler(void);
void uart_write(char *ch);
void int_to_string(uint8_t value, char *str);

//tim2
void TIM2_setup();
void TIM2_start_stop(uint8_t flag);
void TIM2_delay_us(uint32_t us);
void TIM2_delay_ms(uint32_t ms);
void TIM2_IRQHandler(void);

//dht11
void dht11_setup();
void dht11_start();
uint8_t dht11_ping();
uint8_t dht11_read();
void uart_info_dht11(uint8_t HI, uint8_t HD, uint8_t TI, uint8_t TD);

// I2C1
void I2C1_setup(void);
void I2C1_start(void);
void I2C1_stop(void);
void I2C1_write(uint8_t data);
void OLED_send_command(uint8_t command);
void OLED_send_data(uint8_t data);
void OLED_init(void);

//debug
void debug();



int main(void)
{

	uint8_t HumidadeI = 0, HumidadeD = 0, TemperaturaI = 0, TemperaturaD = 0;

	RCC_setup();

	USART1_setup();
	uart_write("usart set\n\r");

	debug();
	uart_write("debug set\n\r");

	TIM2_setup();
	uart_write("tim2 set\n\r");

	dht11_setup();
	uart_write("dht11 set\n\r");

    I2C1_setup();
    uart_write("I2C set\n\r");

    OLED_init();
    uart_write("I2C init\n\r");

    //OLED_send_command(0xAF); // Comando para ligar o OLED (Display ON)

	while(1)
	{
		TIM2_delay_ms(1000);
		GPIOC->ODR ^= (1 << 13);
		if(dht11_ping()){


			TemperaturaI = dht11_read();
			TemperaturaD = dht11_read();

			HumidadeI = dht11_read();
			HumidadeD = dht11_read();

			uart_info_dht11(TemperaturaI,TemperaturaD,HumidadeI,HumidadeD);

			GPIOC->ODR ^= (1 << 13);
			TIM2_delay_ms(1000);
			GPIOC->ODR ^= (1 << 13);

		}




	}
}

void debug(){
	// Set Bit 3 to enable GPIOB clock
	RCC->APB2ENR |= (1 << 3);
	RCC->APB2ENR |= (1 << 4);


	GPIOC->CRH &= 0xFF0FFFFF;
	GPIOC->CRH |= 0x00200000;
	// Make GPIOB Pin11 output
	GPIOB->CRH &= 0xFFFF0FFF;
	GPIOB->CRH |= 0x00002000;

	// Reset GPIOB Pin11
	GPIOB->ODR |= (1 << 11);
	//GPIOC->ODR |= (1 << 13);
}

void RCC_setup(void)
{
    // Habilitar o HSE (High-Speed External Clock)
    RCC->CR |= RCC_CR_HSEON;  // Liga o HSE
    while (!(RCC->CR & RCC_CR_HSERDY));  // Aguarda até que o HSE esteja pronto

    // Configurar o PLL para usar o HSE como fonte e multiplicar por 9
    RCC->CFGR &= ~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL); // Limpar as configurações de PLL
    RCC->CFGR |= ( (1 << 16) | RCC_CFGR_PLLMULL9); // Configurar PLL com HSE e multiplicação por 9

    // Ligar o PLL
    RCC->CR |= RCC_CR_PLLON;  // Habilitar o PLL
    while (!(RCC->CR & RCC_CR_PLLRDY));  // Esperar o PLL ficar pronto

    // Configurar os divisores AHB, APB1 e APB2
    RCC->CFGR |= RCC_CFGR_HPRE_DIV1;   // Sem divisão para o AHB (HCLK = SYSCLK)
    RCC->CFGR |= RCC_CFGR_PPRE1_DIV2;  // Divisor 2 para APB1 (PCLK1 = HCLK/2)
    RCC->CFGR |= RCC_CFGR_PPRE2_DIV1;  // Sem divisão para APB2 (PCLK2 = HCLK)

    // Configurar o Flash latency
    FLASH->ACR |= FLASH_ACR_LATENCY_2;  // 2 ciclos de espera para 72 MHz

    // Selecionar o PLL como a fonte do SYSCLK
    RCC->CFGR &= ~RCC_CFGR_SW;  // Limpar bits de seleção do SYSCLK
    RCC->CFGR |= RCC_CFGR_SW_PLL;  // Selecionar o PLL como a fonte de clock

    while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL);  // Esperar a transição para PLL

    // Desabilitar o HSI (opcional, se não for mais usado)
    RCC->CR &= ~RCC_CR_HSION;
}


void USART1_setup(){

	/*UART1 Pin configuration*/
	//enable clock access to GPIOA
	RCC->APB2ENR|=RCC_APB2ENR_IOPAEN;

	/*Configure PA9(TX) as output maximum speed to 50MHz
	 * and alternate output push-pull mode for USART1*/
	GPIOA->CRH &= 0xFFFFFF0F;
	GPIOA->CRH |= 0x000000B0;

	//Configure PA10(RX) as as input floating as following
	GPIOA->CRH &= 0xFFFFF0FF;
	GPIOA->CRH |= 0x00000400;

	/*USART1 configuration*/

	//enable clock access to USART1
	RCC->APB2ENR |= RCC_APB2ENR_USART1EN;
	//Enable receiver
	USART1->CR1 |= USART_CR1_RE | USART_CR1_TE;
	//Set Baud Rate
	USART1->BRR = ((CPU_CLK_72m + (BaudRate/2U))/BaudRate);
	//Enable RXNIE interrupt
	USART1->CR1|=USART_CR1_RXNEIE;
	//Enable USART1 interrupt in NVIC
	NVIC_EnableIRQ(USART1_IRQn);
	//Enable UART
	USART1->CR1 |= USART_CR1_UE;
}

void uart_write(char *ch)
{
	while(*ch)
	{
		//Make sure the transmit data register is empty
		while(!(USART1->SR & USART_SR_TXE)){}
		//Write to transmit data register
		USART1->DR	=  (*ch & 0xFF);
		ch++;
	}
}

void uart_info_dht11(uint8_t HI, uint8_t HD, uint8_t TI, uint8_t TD){

    int_to_string(TI,buffer);
    uart_write(buffer);
    uart_write(",");
    int_to_string(TD,buffer);
    uart_write(buffer);
    uart_write(" C\n\r");

    int_to_string(HI,buffer);
    uart_write(buffer);
    uart_write(",");
    int_to_string(HD,buffer);
    uart_write(buffer);
    uart_write(" %\n\r");

}

void int_to_string(uint8_t value, char *str) {
    int i = 0;

    // Processa cada dígito e coloca no array
    do {
        str[i++] = (value % 10) + '0';  // Extrai o último dígito e converte para char
        value /= 10;                    // Remove o dígito processado
    } while (value > 0);

    // Adiciona o terminador nulo
    str[i] = '\0';

    // Inverte a string, já que os dígitos foram colocados em ordem inversa
    for (int j = 0; j < i / 2; j++) {
        char temp = str[j];
        str[j] = str[i - j - 1];
        str[i - j - 1] = temp;
    }
}

void USART1_IRQHandler(void)
{
    /* Verifica a origem da interrupção */
    if (USART1->SR & USART_SR_RXNE) /* Recebeu um caractere */
    {
        /* Lê o dado */
        ch = USART1->DR;
        uart_write(&ch);
        // Armazena o caractere no buffer
        if (buffer_index < sizeof(buffer) - 1)  // Certifica-se de não ultrapassar o tamanho do buffer
        {
            buffer[buffer_index++] = ch;

            // Verifica se o caractere recebido é o fim da string (ex: '\n' ou '\r')
            if (ch == '\n' || ch == '\r')
            {
                buffer[buffer_index - 1] = '\0';  // Substitui o terminador por NULL para formar a string

                ch = '\n';
                uart_write(&ch);


                buffer_index = 0;  // Reseta o índice para a próxima string




            }
        }
        else
        {
            // Buffer cheio, reiniciar para evitar estouro
            buffer_index = 0;
        }

    }
}

void TIM2_setup(){

	// Enable clock access to timer2
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;

	// Configure timer2
	TIM2->PSC = tim2_psc - 1; 	//8000000/8 =100000 i.e. 1us
	TIM2->ARR = 1 - 1 ;


	/* Set UIE(Update interrupt enable) bit
	 * in TIMx DMA/Interrupt enable register (TIMx_DIER)
	 * to enable timer interrupt*/
	TIM2->DIER |= TIM_DIER_UIE;

	// Enable timer2 interrupt in NVIC
	NVIC_EnableIRQ(TIM2_IRQn);


}

void TIM2_delay_ms(uint32_t ms){

	while(ms--){
		TIM2_delay_us(1000);

	};

}

void TIM2_delay_us(uint32_t us){

	// Disable the timer
	TIM2->CR1 &= ~TIM_CR1_CEN;

	TIM2->ARR = us -1;

	// Enable the timer
	TIM2->CR1 |= TIM_CR1_CEN;

	while(!flag);
	flag = 0;

}



void TIM2_start_stop(uint8_t flag){

	if(flag){
		// Enable the timer
		TIM2->CR1 |= TIM_CR1_CEN;
	}else{
		// Disable the timer
		TIM2->CR1 &= ~TIM_CR1_CEN;
	}
}
/*
 * TIM2interrupt handler
 */
void TIM2_IRQHandler(void)
{
	if(TIM2->SR & TIM_SR_UIF)
	{
		TIM2->SR &=~TIM_SR_UIF;
		flag = 1;
		GPIOB->ODR ^= (1 << 11);

		TIM2->CR1 &= ~TIM_CR1_CEN;

	}

}

void dht11_setup(){

	RCC->APB2ENR |= RCC_APB2ENR_IOPBEN;

	DHT11_GRUPO->CRH &= ~(GPIO_CRH_MODE9 | GPIO_CRH_CNF9);
	DHT11_GRUPO->CRH |= GPIO_CRH_MODE9_1;

    DHT11_GRUPO->ODR &= ~DHT11_PIN;  // Pino em LOW

}

void dht11_start(){

	dht11_setup();

	DHT11_GRUPO->ODR &= ~DHT11_PIN;
	TIM2_delay_ms(18);

	DHT11_GRUPO->ODR |= DHT11_PIN;
	TIM2_delay_us(30);

}

uint8_t dht11_ping() {

	//uart_write("ping...");
	uart_write("ping test!\n\r");
	dht11_start();


    uint8_t sinal = 0;

    DHT11_GRUPO->CRH &= ~(GPIO_CRH_MODE9 | GPIO_CRH_CNF9);
    DHT11_GRUPO->CRH |= GPIO_CRH_CNF9_0; //float input

    // Esperar o DHT11 puxar o pino para baixo
    TIM2_delay_us(40);

    if (!(DHT11_GRUPO->IDR & DHT11_PIN)){
    	//uart_write("pong!\n\r");
    	TIM2_delay_us(80);
        if (DHT11_GRUPO->IDR & DHT11_PIN) {
            sinal = 1; // DHT11 respondeu
            //uart_write("pong!\n\r");
        }
    }

    // Esperar o fim da resposta
    while (DHT11_GRUPO->IDR & DHT11_PIN);
    //uart_write("\n\r ping encerrado\n\r");
    return sinal;
}




uint8_t dht11_read(){
	uint8_t i, result = 0;

    for (i = 0; i < 8; i++) {

        // Esperar o pino ficar baixo
        while (!(DHT11_GRUPO->IDR & DHT11_PIN));

        // Esperar 40 us e verificar o estado do pino
        TIM2_delay_us(40);
        if (DHT11_GRUPO->IDR & DHT11_PIN) {
            result |= (1 << (7 - i)); // Se o pino estiver alto, é 1
        }

        // Esperar o pino ficar baixo de novo
        while (DHT11_GRUPO->IDR & DHT11_PIN);
    }

    return result;
}





void I2C1_setup(void) {

    RCC->APB2ENR |= RCC_APB2ENR_IOPBEN;

    RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;

    // Configurar PB6 (SCL) e PB7 (SDA) como AF Open-Drain, 50 MHz
    GPIOB->CRL &= ~((0xF << 24) | (0xF << 28)); // Limpar configuração de PB6 e PB7
    GPIOB->CRL |= (0xB << 24) | (0xB << 28);    // Configurar como Alternate Function Open-Drain, 50 MHz

    // Resetar o I2C1
    I2C1->CR1 |= I2C_CR1_SWRST;
    I2C1->CR1 &= ~I2C_CR1_SWRST;

    // Configurar o clock I2C1 (APB1 é 36 MHz)
    I2C1->CR2 = 36;  // 36 MHz de clock periférico

    // Para 400kHz: CCR = 36 MHz / (2 * 400kHz) = 45
    I2C1->CCR = 45;


    // Configurar o tempo máximo de subida para 1000 ns em modo rápido
    // Fórmula: TRISE = (F_APB1 * max_rise_time) + 1
    // Para 400 kHz: TRISE = (36 MHz * 300 ns) + 1 = 13
    I2C1->TRISE = 13;

    I2C1->OAR1 = 0;
    I2C1->OAR1 &= ~I2C_OAR1_ADDMODE;

    // Desabilitar modo de endereço duplo e chamada geral
    I2C1->OAR2 = 0;               // Endereço 2 desabilitado
    I2C1->CR1 &= ~I2C_CR1_ENGC;   // Desabilitar General Call

    // Configurar modo de alongamento de clock (Stretching habilitado)
    I2C1->CR1 &= ~I2C_CR1_NOSTRETCH; // Habilitar alongamento do clock

    // Habilitar o I2C1
    I2C1->CR1 |= I2C_CR1_PE;
}

void I2C1_start(void) {

    I2C1->CR1 |= I2C_CR1_START;
    uart_write("I2C start!\n\r");


    while (!(I2C1->SR1 & I2C_SR1_SB));
    uart_write("I2C pong!\n\r");
    (void)I2C1->SR1; // Ler o registro SR1 para limpar o bit SB

}

void I2C1_stop(void) {
    // Gerar condição de stop
    I2C1->CR1 |= I2C_CR1_STOP;
}

void I2C1_write(uint8_t data) {

    // Escrever o dado no DR
    I2C1->DR = data;
    uart_write("I2C - write ping!\n\r");

    // Esperar até que o dado seja transmitido
    while (!(I2C1->SR1 & I2C_SR1_TXE));
    uart_write("I2C - write pong!\n\r");

}

void OLED_send_command(uint8_t command) {
    // Iniciar a comunicação I2C
    I2C1_start();
    // Enviar o endereço do OLED e o bit de escrita
    uart_write("I2C escrita start!\n\r");
    I2C1_write(OLED_ADDRESS << 1);
    // Enviar o byte de controle para indicar que é um comando
    I2C1_write(0x00);
    // Enviar o comando
    I2C1_write(command);
    // Parar a comunicação I2C
    I2C1_stop();
}

void OLED_send_data(uint8_t data) {
    // Iniciar a comunicação I2C
    I2C1_start();
    // Enviar o endereço do OLED e o bit de escrita
    I2C1_write(OLED_ADDRESS << 1);
    // Enviar o byte de controle para indicar que é dado
    I2C1_write(0x40);
    // Enviar o dado
    I2C1_write(data);
    // Parar a comunicação I2C
    I2C1_stop();
}

void OLED_init(void) {
    // Sequência de inicialização para o SSD1306
    OLED_send_command(0xAE); // Display OFF
    OLED_send_command(0x20); // Set Memory Addressing Mode
    OLED_send_command(0x10); // Set Page Addressing Mode
    OLED_send_command(0xB0); // Set Page Start Address for Page Addressing Mode
    OLED_send_command(0xC8); // Set COM Output Scan Direction
    OLED_send_command(0x00); // Set low column address
    OLED_send_command(0x10); // Set high column address
    OLED_send_command(0x40); // Set start line address
    OLED_send_command(0x81); // Set contrast control register
    OLED_send_command(0xFF); // Maximum contrast
    OLED_send_command(0xA1); // Set segment re-map 0 to 127
    OLED_send_command(0xA6); // Set normal display
    OLED_send_command(0xA8); // Set multiplex ratio (1 to 64)
    OLED_send_command(0x3F); // 1/64 duty
    OLED_send_command(0xA4); // Output RAM to display
    OLED_send_command(0xD3); // Set display offset
    OLED_send_command(0x00); // No offset
    OLED_send_command(0xD5); // Set display clock divide ratio/oscillator frequency
    OLED_send_command(0xF0); // Set divide ratio
    OLED_send_command(0xD9); // Set pre-charge period
    OLED_send_command(0x22);
    OLED_send_command(0xDA); // Set COM pins hardware configuration
    OLED_send_command(0x12);
    OLED_send_command(0xDB); // Set vcomh
    OLED_send_command(0x20); // 0.77x Vcc
    OLED_send_command(0x8D); // Set DC-DC enable
    OLED_send_command(0x14);
    OLED_send_command(0xAF); // Display ON
}


