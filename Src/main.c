/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "stm32f1xx.h"

/*
 * macros a sererm definidas
 * */

//rcc
#define CPU_CLK_8m 	8000000
#define CPU_CLK_72m 	72000000

//timer
#define tim2_psc 72

//usart
#define BaudRate	115200

//dht11
#define DHT11_PIN 	0x200
#define DHT11_GRUPO GPIOB

//I2C1
#define OLED_ADDRESS  0x3C
#define SSD1306_linha           64
#define SSD1306_coluna         128
#define OLED_PAGES  (SSD1306_coluna / 8)

/*
 * variaveis globais
 * */

//uart
char ch = '\000';
char buffer[20];
uint8_t  buffer_index = 0;

//timer
uint8_t flag = 0;

//i2c


//Oled
const uint8_t font5x7[][5] = {
    {0x00, 0x00, 0x00, 0x00, 0x00}, // 32  <space>
    {0x00, 0x00, 0x5F, 0x00, 0x00}, // 33  !
    {0x00, 0x07, 0x00, 0x07, 0x00}, // 34  "
    {0x14, 0x7F, 0x14, 0x7F, 0x14}, // 35  #
    {0x24, 0x2A, 0x7F, 0x2A, 0x12}, // 36  $
    {0x23, 0x13, 0x08, 0x64, 0x62}, // 37  %
    {0x36, 0x49, 0x55, 0x22, 0x50}, // 38  &
    {0x00, 0x05, 0x03, 0x00, 0x00}, // 39  '
    {0x00, 0x1C, 0x22, 0x41, 0x00}, // 40  (
    {0x00, 0x41, 0x22, 0x1C, 0x00}, // 41  )
    {0x14, 0x08, 0x3E, 0x08, 0x14}, // 42  *
    {0x08, 0x08, 0x3E, 0x08, 0x08}, // 43  +
    {0x00, 0x50, 0x30, 0x00, 0x00}, // 44  ,
    {0x08, 0x08, 0x08, 0x08, 0x08}, // 45  -
    {0x00, 0x60, 0x60, 0x00, 0x00}, // 46  .
    {0x20, 0x10, 0x08, 0x04, 0x02}, // 47  /
    {0x3E, 0x51, 0x49, 0x45, 0x3E}, // 48  0
    {0x00, 0x42, 0x7F, 0x40, 0x00}, // 49  1
    {0x42, 0x61, 0x51, 0x49, 0x46}, // 50  2
    {0x21, 0x41, 0x45, 0x4B, 0x31}, // 51  3
    {0x18, 0x14, 0x12, 0x7F, 0x10}, // 52  4
    {0x27, 0x45, 0x45, 0x45, 0x39}, // 53  5
    {0x3C, 0x4A, 0x49, 0x49, 0x30}, // 54  6
    {0x01, 0x71, 0x09, 0x05, 0x03}, // 55  7
    {0x36, 0x49, 0x49, 0x49, 0x36}, // 56  8
    {0x06, 0x49, 0x49, 0x29, 0x1E}, // 57  9
    {0x00, 0x36, 0x36, 0x00, 0x00}, // 58  :
	{0x00, 0x56, 0x36, 0x00, 0x00}, // 59  ;
	    {0x08, 0x14, 0x22, 0x41, 0x00}, // 60  <
	    {0x14, 0x14, 0x14, 0x14, 0x14}, // 61  =
	    {0x00, 0x41, 0x22, 0x14, 0x08}, // 62  >
	    {0x02, 0x01, 0x51, 0x09, 0x06}, // 63  ?
	    {0x32, 0x49, 0x79, 0x41, 0x3E}, // 64  @
	    {0x7E, 0x11, 0x11, 0x11, 0x7E}, // 65  A
	    {0x7F, 0x49, 0x49, 0x49, 0x36}, // 66  B
	    {0x3E, 0x41, 0x41, 0x41, 0x22}, // 67  C
	    {0x7F, 0x41, 0x41, 0x22, 0x1C}, // 68  D
	    {0x7F, 0x49, 0x49, 0x49, 0x41}, // 69  E
	    {0x7F, 0x09, 0x09, 0x09, 0x01}, // 70  F
	    {0x3E, 0x41, 0x49, 0x49, 0x7A}, // 71  G
	    {0x7F, 0x08, 0x08, 0x08, 0x7F}, // 72  H
	    {0x00, 0x41, 0x7F, 0x41, 0x00}, // 73  I
	    {0x20, 0x40, 0x41, 0x3F, 0x01}, // 74  J
	    {0x7F, 0x08, 0x14, 0x22, 0x41}, // 75  K
	    {0x7F, 0x40, 0x40, 0x40, 0x40}, // 76  L
	    {0x7F, 0x02, 0x0C, 0x02, 0x7F}, // 77  M
	    {0x7F, 0x04, 0x08, 0x10, 0x7F}, // 78  N
	    {0x3E, 0x41, 0x41, 0x41, 0x3E}, // 79  O
	    {0x7F, 0x09, 0x09, 0x09, 0x06}, // 80  P
	    {0x3E, 0x41, 0x51, 0x21, 0x5E}, // 81  Q
	    {0x7F, 0x09, 0x19, 0x29, 0x46}, // 82  R
	    {0x46, 0x49, 0x49, 0x49, 0x31}, // 83  S
	    {0x01, 0x01, 0x7F, 0x01, 0x01}, // 84  T
	    {0x3F, 0x40, 0x40, 0x40, 0x3F}, // 85  U
	    {0x1F, 0x20, 0x40, 0x20, 0x1F}, // 86  V
	    {0x7F, 0x20, 0x18, 0x20, 0x7F}, // 87  W
	    {0x63, 0x14, 0x08, 0x14, 0x63}, // 88  X
	    {0x03, 0x04, 0x78, 0x04, 0x03}, // 89  Y
	    {0x61, 0x51, 0x49, 0x45, 0x43}, // 90  Z
	    {0x00, 0x7F, 0x41, 0x41, 0x00}, // 91  [
	    {0x02, 0x04, 0x08, 0x10, 0x20}, // 92  '\'
	    {0x00, 0x41, 0x41, 0x7F, 0x00}, // 93  ]
	    {0x04, 0x02, 0x01, 0x02, 0x04}, // 94  ^
	    {0x40, 0x40, 0x40, 0x40, 0x40}, // 95  _
	    {0x00, 0x03, 0x05, 0x00, 0x00}, // 96  `
    // Mais caracteres...
};

uint8_t atual_x , atual_y= 0;


/*
 * funções declaradas
 * */

void RCC_setup();


//usart1
void USART1_setup();
void USART1_IRQHandler(void);
void uart_write(char *ch);
void int_to_string(uint8_t value, char *str);

//tim2
void TIM2_setup();
void TIM2_start_stop(uint8_t flag);
void TIM2_delay_us(uint32_t us);
void TIM2_delay_ms(uint32_t ms);
void TIM2_IRQHandler(void);

//dht11
void dht11_setup();
void dht11_start();
uint8_t dht11_ping();
uint8_t dht11_read();
void uart_info_dht11(uint8_t HI, uint8_t HD, uint8_t TI, uint8_t TD);

// I2C1
void I2C1_setup(void);
void I2C1_start(void);
void I2C1_stop(void);
void I2C1_write(uint8_t data);

//Oled
void OLED_send_command(uint8_t command);
void OLED_send_data(uint8_t data);
void OLED_init(void);
void OLED_Fill(uint8_t val);
void OLED_DrawChar(uint8_t x, uint8_t y, char c);
void OLED_DrawString(uint8_t x, uint8_t y, const char* str);
void OLED_info_dht11(uint8_t HI, uint8_t HD, uint8_t TI, uint8_t TD);

//debug
void Oled_intro();
void intToString(uint8_t num, char* str);
void debug();



int main(void)
{

	uint8_t HumidadeI = 0, HumidadeD = 0, TemperaturaI = 0, TemperaturaD = 0;

	RCC_setup();

	USART1_setup();
	uart_write("usart set\n\r");

	//debug();
	//uart_write("debug set\n\r");

	TIM2_setup();
	uart_write("tim2 set\n\r");

	dht11_setup();
	uart_write("dht11 set\n\r");

    I2C1_setup();
    uart_write("I2C set\n\r");

    OLED_init();
    uart_write("I2C init\n\r");

    OLED_send_command(0xAF); // Comando para ligar o OLED (Display ON)

    Oled_intro();



	while(1)
	{
		TIM2_delay_ms(1000);
		GPIOC->ODR ^= (1 << 13);
		if(dht11_ping()){


			TemperaturaI = dht11_read();
			TemperaturaD = dht11_read();

			HumidadeI = dht11_read();
			HumidadeD = dht11_read();

			uart_info_dht11(TemperaturaI,TemperaturaD,HumidadeI,HumidadeD);
			OLED_info_dht11(TemperaturaI,TemperaturaD,HumidadeI,HumidadeD);


			GPIOC->ODR ^= (1 << 13);
			TIM2_delay_ms(1000);
			GPIOC->ODR ^= (1 << 13);

		}




	}
}

void debug(){
	// Set Bit 3 to enable GPIOB clock
	RCC->APB2ENR |= (1 << 3);
	RCC->APB2ENR |= (1 << 4);


	GPIOC->CRH &= 0xFF0FFFFF;
	GPIOC->CRH |= 0x00200000;
	// Make GPIOB Pin11 output
	GPIOB->CRH &= 0xFFFF0FFF;
	GPIOB->CRH |= 0x00002000;

	// Reset GPIOB Pin11
	GPIOB->ODR |= (1 << 11);
	//GPIOC->ODR |= (1 << 13);
}

void RCC_setup(void)
{
    // Habilitar o HSE (High-Speed External Clock)
    RCC->CR |= RCC_CR_HSEON;  // Liga o HSE
    while (!(RCC->CR & RCC_CR_HSERDY));  // Aguarda até que o HSE esteja pronto

    // Configurar o PLL para usar o HSE como fonte e multiplicar por 9
    RCC->CFGR &= ~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL); // Limpar as configurações de PLL
    RCC->CFGR |= ( (1 << 16) | RCC_CFGR_PLLMULL9); // Configurar PLL com HSE e multiplicação por 9

    // Ligar o PLL
    RCC->CR |= RCC_CR_PLLON;  // Habilitar o PLL
    while (!(RCC->CR & RCC_CR_PLLRDY));  // Esperar o PLL ficar pronto

    // Configurar os divisores AHB, APB1 e APB2
    RCC->CFGR |= RCC_CFGR_HPRE_DIV1;   // Sem divisão para o AHB (HCLK = SYSCLK)
    RCC->CFGR |= RCC_CFGR_PPRE1_DIV2;  // Divisor 2 para APB1 (PCLK1 = HCLK/2)
    RCC->CFGR |= RCC_CFGR_PPRE2_DIV1;  // Sem divisão para APB2 (PCLK2 = HCLK)

    // Configurar o Flash latency
    FLASH->ACR |= FLASH_ACR_LATENCY_2;  // 2 ciclos de espera para 72 MHz

    // Selecionar o PLL como a fonte do SYSCLK
    RCC->CFGR &= ~RCC_CFGR_SW;  // Limpar bits de seleção do SYSCLK
    RCC->CFGR |= RCC_CFGR_SW_PLL;  // Selecionar o PLL como a fonte de clock

    while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL);  // Esperar a transição para PLL

    // Desabilitar o HSI (opcional, se não for mais usado)
    RCC->CR &= ~RCC_CR_HSION;
}


void USART1_setup(){

	/*UART1 Pin configuration*/
	//enable clock access to GPIOA
	RCC->APB2ENR|=RCC_APB2ENR_IOPAEN;

	/*Configure PA9(TX) as output maximum speed to 50MHz
	 * and alternate output push-pull mode for USART1*/
	GPIOA->CRH &= 0xFFFFFF0F;
	GPIOA->CRH |= 0x000000B0;

	//Configure PA10(RX) as as input floating as following
	GPIOA->CRH &= 0xFFFFF0FF;
	GPIOA->CRH |= 0x00000400;

	/*USART1 configuration*/

	//enable clock access to USART1
	RCC->APB2ENR |= RCC_APB2ENR_USART1EN;
	//Enable receiver
	USART1->CR1 |= USART_CR1_RE | USART_CR1_TE;
	//Set Baud Rate
	USART1->BRR = ((CPU_CLK_72m + (BaudRate/2U))/BaudRate);
	//Enable RXNIE interrupt
	USART1->CR1|=USART_CR1_RXNEIE;
	//Enable USART1 interrupt in NVIC
	NVIC_EnableIRQ(USART1_IRQn);
	//Enable UART
	USART1->CR1 |= USART_CR1_UE;
}

void uart_write(char *ch)
{
	while(*ch)
	{
		//Make sure the transmit data register is empty
		while(!(USART1->SR & USART_SR_TXE)){}
		//Write to transmit data register
		USART1->DR	=  (*ch & 0xFF);
		ch++;
	}
}

void uart_info_dht11(uint8_t HI, uint8_t HD, uint8_t TI, uint8_t TD){

    int_to_string(TI,buffer);
    uart_write(buffer);
    uart_write(",");
    int_to_string(TD,buffer);
    uart_write(buffer);
    uart_write(" C\n\r");

    int_to_string(HI,buffer);
    uart_write(buffer);
    uart_write(",");
    int_to_string(HD,buffer);
    uart_write(buffer);
    uart_write(" %\n\r");

}

void int_to_string(uint8_t value, char *str) {
    int i = 0;

    // Processa cada dígito e coloca no array
    do {
        str[i++] = (value % 10) + '0';  // Extrai o último dígito e converte para char
        value /= 10;                    // Remove o dígito processado
    } while (value > 0);

    // Adiciona o terminador nulo
    str[i] = '\0';

    // Inverte a string, já que os dígitos foram colocados em ordem inversa
    for (int j = 0; j < i / 2; j++) {
        char temp = str[j];
        str[j] = str[i - j - 1];
        str[i - j - 1] = temp;
    }
}

void USART1_IRQHandler(void)
{
    /* Verifica a origem da interrupção */
    if (USART1->SR & USART_SR_RXNE) /* Recebeu um caractere */
    {
        /* Lê o dado */
        ch = USART1->DR;
        uart_write(&ch);
        // Armazena o caractere no buffer
        if (buffer_index < sizeof(buffer) - 1)  // Certifica-se de não ultrapassar o tamanho do buffer
        {
            buffer[buffer_index++] = ch;

            // Verifica se o caractere recebido é o fim da string (ex: '\n' ou '\r')
            if (ch == '\n' || ch == '\r')
            {
                buffer[buffer_index - 1] = '\0';  // Substitui o terminador por NULL para formar a string

                ch = '\n';
                uart_write(&ch);


                buffer_index = 0;  // Reseta o índice para a próxima string




            }
        }
        else
        {
            // Buffer cheio, reiniciar para evitar estouro
            buffer_index = 0;
        }

    }
}

void TIM2_setup(){

	// Enable clock access to timer2
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;

	// Configure timer2
	TIM2->PSC = tim2_psc - 1; 	//8000000/8 =100000 i.e. 1us
	TIM2->ARR = 1 - 1 ;


	/* Set UIE(Update interrupt enable) bit
	 * in TIMx DMA/Interrupt enable register (TIMx_DIER)
	 * to enable timer interrupt*/
	TIM2->DIER |= TIM_DIER_UIE;

	// Enable timer2 interrupt in NVIC
	NVIC_EnableIRQ(TIM2_IRQn);


}

void TIM2_delay_ms(uint32_t ms){

	while(ms--){
		TIM2_delay_us(1000);

	};

}

void TIM2_delay_us(uint32_t us){

	// Disable the timer
	TIM2->CR1 &= ~TIM_CR1_CEN;

	TIM2->ARR = us -1;

	// Enable the timer
	TIM2->CR1 |= TIM_CR1_CEN;

	while(!flag);
	flag = 0;

}



void TIM2_start_stop(uint8_t flag){

	if(flag){
		// Enable the timer
		TIM2->CR1 |= TIM_CR1_CEN;
	}else{
		// Disable the timer
		TIM2->CR1 &= ~TIM_CR1_CEN;
	}
}
/*
 * TIM2interrupt handler
 */
void TIM2_IRQHandler(void)
{
	if(TIM2->SR & TIM_SR_UIF)
	{
		TIM2->SR &=~TIM_SR_UIF;
		flag = 1;
		GPIOB->ODR ^= (1 << 11);

		TIM2->CR1 &= ~TIM_CR1_CEN;

	}

}

void dht11_setup(){

	RCC->APB2ENR |= RCC_APB2ENR_IOPBEN;

	DHT11_GRUPO->CRH &= ~(GPIO_CRH_MODE9 | GPIO_CRH_CNF9);
	DHT11_GRUPO->CRH |= GPIO_CRH_MODE9_1;

    DHT11_GRUPO->ODR &= ~DHT11_PIN;  // Pino em LOW

}

void dht11_start(){

	dht11_setup();

	DHT11_GRUPO->ODR &= ~DHT11_PIN;
	TIM2_delay_ms(18);

	DHT11_GRUPO->ODR |= DHT11_PIN;
	TIM2_delay_us(30);

}

uint8_t dht11_ping() {

	//uart_write("ping...");
	uart_write("ping test!\n\r");
	dht11_start();


    uint8_t sinal = 0;

    DHT11_GRUPO->CRH &= ~(GPIO_CRH_MODE9 | GPIO_CRH_CNF9);
    DHT11_GRUPO->CRH |= GPIO_CRH_CNF9_0; //float input

    // Esperar o DHT11 puxar o pino para baixo
    TIM2_delay_us(40);

    if (!(DHT11_GRUPO->IDR & DHT11_PIN)){
    	//uart_write("pong!\n\r");
    	TIM2_delay_us(80);
        if (DHT11_GRUPO->IDR & DHT11_PIN) {
            sinal = 1; // DHT11 respondeu
            //uart_write("pong!\n\r");
        }
    }

    // Esperar o fim da resposta
    while (DHT11_GRUPO->IDR & DHT11_PIN);
    //uart_write("\n\r ping encerrado\n\r");
    return sinal;
}




uint8_t dht11_read(){
	uint8_t i, result = 0;

    for (i = 0; i < 8; i++) {

        // Esperar o pino ficar baixo
        while (!(DHT11_GRUPO->IDR & DHT11_PIN));

        // Esperar 40 us e verificar o estado do pino
        TIM2_delay_us(40);
        if (DHT11_GRUPO->IDR & DHT11_PIN) {
            result |= (1 << (7 - i)); // Se o pino estiver alto, é 1
        }

        // Esperar o pino ficar baixo de novo
        while (DHT11_GRUPO->IDR & DHT11_PIN);
    }

    return result;
}





void I2C1_setup(void) {

    RCC->APB2ENR |= RCC_APB2ENR_IOPBEN;

    RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;

    GPIOB->CRL &= ~(GPIO_CRL_MODE6 | GPIO_CRL_CNF6 | GPIO_CRL_MODE7 | GPIO_CRL_CNF7);  // Limpa os bits
    GPIOB->CRL |= (GPIO_CRL_MODE6_1 | GPIO_CRL_CNF6_1 | GPIO_CRL_CNF6_0); // AF open-drain e 10MHz
    GPIOB->CRL |= (GPIO_CRL_MODE7_1 | GPIO_CRL_CNF7_1 | GPIO_CRL_CNF7_0); // AF open-drain e 10MHz

    // Configurar o clock I2C1 (APB1 é 36 MHz)
    I2C1->CR2 = 36;  // 36 MHz de clock periférico
    I2C1->CCR = 180;
    I2C1->TRISE = 37;

    // Habilitar o I2C1
    I2C1->CR1 |= I2C_CR1_PE;
}

void I2C1_start(void) {

    I2C1->CR1 |= I2C_CR1_START;
    //uart_write("I2C start!\n\r");


    while (!(I2C1->SR1 & I2C_SR1_SB));
    (void)I2C1->SR1; // Ler o registro SR1 para limpar o bit SB

}

void I2C1_stop(void) {
    // Gerar condição de stop
    I2C1->CR1 |= I2C_CR1_STOP;
    //uart_write("I2C stop!\n\r");
}

void I2C1_write(uint8_t data) {

    // Escrever o dado no DR
    I2C1->DR = data;
    // Esperar até que o dado seja transmitido
    while (!(I2C1->SR1 & I2C_SR1_TXE));
    //uart_write("I2C - write pong!\n\r");
    (void)I2C1->SR2;

}

void OLED_send_command(uint8_t command) {
    // Iniciar a comunicação I2C
    I2C1_start();
    // Enviar o endereço do OLED e o bit de escrita
    //uart_write("I2C escrita start!\n\r");
    I2C1_write(OLED_ADDRESS << 1);
    //uart_write("I2C escrita start ok!\n\r");
    // Enviar o byte de controle para indicar que é um comando
    //uart_write("I2C cmd start!\n\r");
    I2C1_write(0x00);
    // Enviar o comando
    I2C1_write(command);
    // Parar a comunicação I2C
    I2C1_stop();
}

void OLED_send_data(uint8_t data) {
    // Iniciar a comunicação I2C
    I2C1_start();
    // Enviar o endereço do OLED e o bit de escrita
    I2C1_write(OLED_ADDRESS << 1);
    // Enviar o byte de controle para indicar que é dado
    I2C1_write(0x40);
    // Enviar o dado
    I2C1_write(data);
    // Parar a comunicação I2C
    I2C1_stop();
}

void OLED_init(void) {
    // Sequência de inicialização para o SSD1306
    OLED_send_command(0xAE); // Display OFF
    OLED_send_command(0x20); // Set Memory Addressing Mode
    OLED_send_command(0x10); // Set Page Addressing Mode
    OLED_send_command(0xB0); // Set Page Start Address for Page Addressing Mode
    OLED_send_command(0xC8); // Set COM Output Scan Direction
    OLED_send_command(0x00); // Set low column address
    OLED_send_command(0x10); // Set high column address
    OLED_send_command(0x40); // Set start line address
    OLED_send_command(0x81); // Set contrast control register
    OLED_send_command(0xFF); // Maximum contrast
    OLED_send_command(0xA1); // Set segment re-map 0 to 127
    OLED_send_command(0xA6); // Set normal display
    OLED_send_command(0xA8); // Set multiplex ratio (1 to 64)
    OLED_send_command(0x3F); // 1/64 duty
    OLED_send_command(0xA4); // Output RAM to display
    OLED_send_command(0xD3); // Set display offset
    OLED_send_command(0x00); // No offset
    OLED_send_command(0xD5); // Set display clock divide ratio/oscillator frequency
    OLED_send_command(0xF0); // Set divide ratio
    OLED_send_command(0xD9); // Set pre-charge period
    OLED_send_command(0x22);
    OLED_send_command(0xDA); // Set COM pins hardware configuration
    OLED_send_command(0x12);
    OLED_send_command(0xDB); // Set vcomh
    OLED_send_command(0x20); // 0.77x Vcc
    OLED_send_command(0x8D); // Set DC-DC enable
    OLED_send_command(0x14);
    OLED_send_command(0xAF); // Display ON
    uart_write("OLED set\n\r");
}

// Função para limpar o display OLED
void OLED_Fill(uint8_t val) {
	if(val > 0xff){
		uart_write("error, tamanho ecedido");
		return;
	}

    for (uint8_t page = 0; page < OLED_PAGES; page++) {
        // Configura o OLED para escrever em cada página
    	OLED_send_command(0xB0 + page);  // Seleciona a página (0 a 7)
    	OLED_send_command(0x00);         // Coluna baixa
    	OLED_send_command(0x10);         // Coluna alta

        // Envia 128 bytes de zeros (0x00) para limpar uma linha inteira
        for (uint8_t col = 0; col < SSD1306_coluna; col++) {
        	OLED_send_data(val);  // 0x00 representa uma linha de pixels "desligados"
        }
    }
}

void OLED_DrawChar(uint8_t x, uint8_t y, char c) {

    // Seleciona a página (linha de pixels de 8 bits de altura)
	OLED_send_command(0xB0 + (y / 8));       // Seleciona a página (Y dividido por 8)
	OLED_send_command(0x00 + (x & 0x0F));    // Coluna baixa
	OLED_send_command(0x10 + ((x >> 4) & 0x0F)); // Coluna alta

    for (int i = 0; i < 5; i++) {
    	OLED_send_data(font5x7[c - 32][i]);  // Envia os bytes da fonte
    }
    OLED_send_data(0x00);  // Espaçamento entre caracteres
}

void OLED_DrawString(uint8_t x, uint8_t y, const char* str) {
    while (*str) {
        OLED_DrawChar(x, y, *str++);
        x += 6;  // Cada caractere tem 5 pixels de largura, mais 1 pixel de espaço
        if (x + 6 >= SSD1306_coluna) {
            x = 0;     // Move para o início da próxima linha
            y += 8;    // Avança para a próxima página
        }
    }
    atual_x = x;
    atual_y = y;
}

void Oled_intro(){
    OLED_Fill(0x00);
    TIM2_delay_ms(100);
    OLED_Fill(0x01);
    TIM2_delay_ms(100);
    OLED_Fill(0x10);
    TIM2_delay_ms(100);
    OLED_Fill(0x00);
}

void OLED_info_dht11(uint8_t HI, uint8_t HD, uint8_t TI, uint8_t TD){

	uint8_t l = 10,h = 10;

	intToString(HI,buffer);
	OLED_DrawString(l,h,buffer);

	OLED_DrawString(atual_x,atual_y,".");

	intToString(HD,buffer);
	OLED_DrawString(atual_x,atual_y,buffer);

	OLED_DrawString(atual_x,atual_y," % DE HUMILDADE");

	l = 10;
	h = 30;

	intToString(TI,buffer);
	OLED_DrawString(l,h,buffer);

	OLED_DrawString(atual_x,atual_y,".");

	intToString(TD,buffer);
	OLED_DrawString(atual_x,atual_y,buffer);

	OLED_DrawString(atual_x,atual_y," C DE CABACO");


}

void intToString(uint8_t num, char* str){
	uint8_t i = 0;
    do {
        buffer[i++] = (num % 10) + '0'; // Adiciona o dígito à string
        num /= 10; // Divide o número por 10
    } while (num > 0);

    buffer[i] = '\0';

    for (int j = 0; j < i / 2; j++) {
        char temp = buffer[j];
        buffer[j] = buffer[i - j - 1];
        buffer[i - j - 1] = temp;
    }

}






